import scalaz._, Scalaz._,  schema._, FreeChoice._
object module extends SchemaModule {
  type Prim[A] = JsonSchema.Prim[A]
  type SumTermId = Int
  type ProductTermId = String
}
import module._, Schema._
import JsonSchema._

val p = ProductTerm("foo", PrimSchema(JsonNumber)) :*: ProductTerm("bar", optional(PrimSchema(JsonString)))
import monocle._
case class Foo(foo: BigDecimal, bar: Option[String])
val repr = Iso[(BigDecimal, Option[String]), Foo]((Foo.apply _).tupled)( f => (f.foo, f.bar))

val schema = record(p, repr)
import org.scalacheck._, Arbitrary._
import scalacheck._, GenModule._


def idNat[F[_]] = new (F ~> F) {
  def apply[A](fa: F[A]): F[A] = fa
}


val GenRepresentation = new Representation[Gen] {
  val prims = new (Prim ~> Gen) {
    override def apply[A](prim: JsonSchema.Prim[A]): Gen[A] = prim match {
      case JsonString => arbitrary[String]
      case JsonNumber => arbitrary[BigDecimal]
      case JsonBool   => arbitrary[Boolean]
      case JsonNull   => arbitrary[Null]
    }
  }

  def handleList[A] = (gen => Gen.listOf[A](gen))

  val handleRecord = idNat[Gen]

  def labelField(label: ProductTermId) = idNat[Gen]

  def zero: Gen[Unit] = Gen.const(())
}

val makeGen = covariantFold(GenRepresentation)
val gen = makeGen(schema)

type Encoder[A] = A => String


val JsonRepresentation = new Representation[Encoder] {
  def prims = new (module.Prim ~> Encoder) {
      override def apply[A](fa: module.Prim[A]): Encoder[A] = fa match {
        case JsonString => a => s""""$a""""
        case JsonBool   => a => if (a) "true" else "false"
        case JsonNull   => _ => "null"
        case JsonNumber => a => a.shows
      }
    }

 def handleRecord = new (Encoder ~> Encoder) {    
    def apply[A](fa: Encoder[A]): Encoder[A] = fa andThen ( "{" + _ + "}")
 }

 
 def labelField(label: String)  = new (Encoder ~> Encoder) {    
    def apply[A](fa: Encoder[A]): Encoder[A] = fa andThen ( s""""$label":"""  + _ )
 }  

 def handleList[A]: Encoder[A] => Encoder[List[A]] = { encA => { list =>
        list.map(encA).mkString("[", ",", "]")

     }     
    
 }
 
 def zero: Encoder[Unit] = ( _` => "null")   
}



val makeEncoder = contravariantFold[Encoder](JsonRepresentation)(functionDecidable(new Monoid[String]{
  def zero = ""
  def append(a: String, b: => String): String = s"$a, $b"
}))